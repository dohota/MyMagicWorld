## Code：
仓库真正存放代码和文件的地方
#### Issues：
项目的“问题追踪系统”，是“项目讨论区 + 任务列表”，包括 报告bug，记录待办事项
#### Pull requests：
协作开发的核心机制————请求合并，合并到主分支
#### discussions：
讨论该项目的使用，体验，提出未来的建议。issues主要用来报告bug，和一些重要的/有潜在风险的功能
#### Actions：
自动化流水线系统（CI/CD）————让“机器帮你干重复的活”
可以自动编译代码，自动跑测试，自动打包，自动发布版本，自动检查代码格式
#### Projects：
项目看板 / 任务管理工具。即轻量Jira
适合规划功能，管理 Issues / PR，小团队项目管理
和 Issues 的关系：Project 是“宏观管理”，Issues 是“具体事项”
## Wiki：
README只是入口介绍
wiki是项目的详细文档系统，知识库
#### 我基本上把重要的介绍内容，各个版本的设想全都写入wiki
用于说明 怎么使用该项目？架构设计是什么？api文档是哪些？开发规范是什么？
#### Security：
安全相关功能集合，避免“公开泄露漏洞”
包含漏洞报告（私下报告安全问题），依赖安全扫描，安全公告（Advisories）
第三方库有漏洞 → GitHub 提醒你，用户发现安全问题 → 私下通知你
#### Insights：
仓库的“数据分析中心”，看项目健康度和活跃度
#### Settings：
仓库的控制中心（仅管理员可见）：管理权限，开关 Issues / Wiki / Projects，设置默认分支，设置保护规则（禁止直接 push main），配置 Actions 权限，删除仓库（慎重）

## (branch:main)主分支
放各个版本的，有代表的，完善的，跨平台的mc引擎，专门用于制作mc类游戏（几乎所有内容都用c或c++编写）

## mce1.0:(branch:mceTextEditor)
实现文本文件编辑器（scintilla+一层简单的ui，可用imgui）

## 2.0:(branch:mceBuilder)
#### 实现自己的构建工具之前，还是用vcpkg+cmake+ninja+ccache+clang吧
实现构建工具：用c或者c++编写，仅支持构建c/c++/简单的脚本语言，可自举，可复现，性能很好增量编译快，与游戏引擎深度绑定
其内置固定版本clang，llvm，目标平台工具链。可以语法高亮，外接lsp，实时分析，自动补全，悬停提示，报错/警告。当然也可以支持其他不同类型的编译器
内置统一的包管理器：用于安装各种游戏依赖，mod，贴图等。这些资源一般放在自己的mcweb上，或者gitlfs，云盘上
甚至还可以稍微改一改编译器源代码，使其更符合项目要求，最后将编译器，构建器，包管理器一起编译成一个构建工具————类似cmake+ninja+ccache+固定版本的clang，可编译，构建，调试，自动化测试

## 3.0:(branch:mcgit)
版本控制工具（不依赖网络，可以仅本地保存）：
借鉴git：性能好，但有点难完全掌握，不适合“超大二进制文件”；
gitLFS：免费额度有限，不是真正的“版本差异存储”（每一版大文件仍是完整上传，只是不影响Git仓库体积，因为存在lfs服务器上）
perforce：收费，大规模二进制文件（tb级）性能很好，有文件锁更安全，权限与流程控制好
svn：集中式版本控制系统，所有历史和“真相”都在服务器上，简单但不灵活，对大型二进制文件支持较好（比gitLFS好）

#### mcgit：
性能很好，安全灵活，可以选择集中式版本控制/分布式版本控制，支持大型二进制文件，自带可视化工具（内嵌于游戏引擎）来比较二进制文件的差异
因为一般二进制文件每次修改几乎都是整文件变化，存储历史容易爆炸（例如 500 MB 的文件，改 50 次 → 25 GB），二进制文件不能像代码一样合并
所以我自定义二进制格式（如mc存档）：实现像文本文件一样的增量存储，并且能可视化比较分析差异
最后游戏引擎，操作系统等各种工具的二进制版本，也都可以通过版本控制工具管理了，也非常便于更新

### 自定义二进制格式（可参考Unreal 插件系统，游戏热更新模块，可以方便用版本控制系统管理，不依赖os）：
不依赖os的二进制指不依赖操作系统提供的‘动态链接 / 模块加载机制（如 .dll），但是仍然运行在 OS 上，仍然需要一个启动入口（exe / 进程），只是不再使用 OS 的模块格式和加载exe 并不是只能调用.dll，它能调用的是“符合某种 ABI/约定的二进制代码”，但dll的好处就是自动解决了这些地狱级问题 ：重定位	✅	ABI	✅	调用约定	✅	安全	✅	调试	✅	，
可以用 clang / gcc / MSVC编译成.obj或 .bin（纯机器码），然后定义你自己的“导出表”（可以约定第一个 64 字节：头，后面是函数地址表，再后面是机器码），最后exe 端自己加载并调用

启动模型：myengine.exe   ← OS唯一认识的东西
        ├─ 初始化 VM / JIT / Runtime
        ├─ 加载 bytecode / IR 文件
        ├─ 解释 / JIT 编译
        └─ 执行
        
方法 A：字节码 + 虚拟机：（如jvm，JavaScript v8引擎，wasm）
#### 并不“必然有 GC”，但现高性能 VM，几乎都会引入某种形式的 GC
[OS 启动 exe]
        ↓
[VM 初始化]
        ↓
[读取 bytecode 文件]
        ↓
[解释执行 或 JIT]
        ↓
[真正的机器指令运行]

方法 B：JIT（LLVM / 自制 JIT）：
#### LLVM AOT 编译后的二进制，几乎就是原生 DLL，区别在于它是从 IR 生成的，而不是你直接手写汇编或 C++。可以把它当作“安全、跨平台、可控制的原生二进制生成工具”。
1.有自制二进制格式或 IR（Intermediate Representation，类似你自己的字节码或 DSL）
2.写一个 前端，把这个自制 IR 转成 LLVM IR
3.LLVM AOT 编译器把 LLVM IR 编译成 原生机器码（.dll 或 .exe）
4.游戏启动文件加载这些原生二进制模块

不管 SSA、寄存器分配、指令选择、优化管线，这些全由 LLVM 负责；只用负责定义 IR、翻译逻辑、接口和 API，性能接近原生 C++（≈95–99%），可控性强（mod、热更新、跨平台）

[exe 启动]
    ↓
[解析 IR / AST]
    ↓
[JIT 编译成机器码]
    ↓
[VirtualAlloc + memcpy]
    ↓
[函数指针直接调用]

#### 1️⃣ 文件级增量更新（最简单）：
每个文件独立更新，不修改已有文件，游戏补丁只包含新增或替换的文件
适用场景：资源包（图片、音效、地图），MOD ，插件系统
优点：简单可靠，不容易破坏已有文件
缺点：如果整个文件改动一点就要替换整个文件，可能比较大
#### 2️⃣ 分块增量更新（块级 patch）
将文件拆成固定大小块（chunk / page），只更新发生变化的块，类似 rsync / bsdiff 原理
适用场景：大文件包（.pak / .obb / ISO）
优点：补丁体积小
缺点：实现复杂，对压缩后的文件效果差（压缩后小改动会改变整块）
#### 3️⃣ 差异压缩 / 二进制 diff（高级）
一般用bsdiff, courgette (Chrome)、SteamPatch
比较旧版本与新版本二进制的差异-》生成 patch-〉更新时应用 patch 重建完整文件
优点：补丁非常小
缺点：对压缩/加密/自定义格式敏感，应用 patch 需要专门程序
#### 4️⃣ 数据/逻辑拆分 + 热更新（游戏专用）
把游戏逻辑和资源拆成小模块：逻辑 → DLL / LLVM AOT / WASM， 资源 → 自制二进制包， 更新时只替换模块或包，热更新/增量更新很简单。Minecraft、Unity、Epic 游戏常用
#### 5️⃣ 热补丁（Patch + Loader）
游戏运行时检查本地 patch 文件，动态加载替换模块
优点：减少用户下载量，可支持热更新
缺点：Loader 复杂，需要确保模块接口兼容

## 4.0:(branch:mceIDE)
文本编辑器+构建工具+版本控制系统+ai助手（或者外接ai）一起编译，变成了一个轻量性能好，专门适应此项目的ide（类似gearry，codelite，textadept，luanti的chunk系统）
并且像clion一样自动保存，自动编译文件

# 5.0:(branch:MCEngine)
内置完整渲染管线，p2p联机系统，几乎除了底层c代码完全使用ecs架构。参考成熟引擎unity，ue；开源普通引擎o3de，torque3d
可制作/改变（内置mcIDE，有类似mcborn的可视化编辑），导出（支持交叉编译，像zig，go那样），运行游戏（内置mc启动器，像curseforge那样读取存档）
一开始实现新功能，只有引擎版本变化；等之后引擎架构，主体稳定了，新功能就只会以插件形式提供，而尽量不改变引擎版本，或者就推出几个发行版供玩家选择
修复bug一般不改变引擎版本，只是3.4.5c变为3.4.5c1（表示是该版本第一次修复bug）

## (branch:mcOS)
若自制mc引擎还是不能压榨出极致的性能，则需要自制一个专门用于运行mc的操作系统：
能适配任何硬件（可以参考linux的硬件驱动，有些闭源硬件Linux也能驱动。90%的os开发者都会在qemu虚拟机里跑内核）
可基于unix/linux内核，可以借鉴tiny core linux（仅11mb，200万多行代码，os不用完全从零开始写）：保留基本驱动+部分控制台功能（用于调试os），去除桌面gui和复杂服务
mc引擎及游戏内容最好要写进内核，以最高权限运行（尤其是chunk系统，ai系统，高性能计算系统）
甚至可以在操作系统的用户态 内置浏览器内核和wine，能够看网页和用windows上软件，甚至可以使用主流操作系统全部功能，但不能影响mc性能

## (branch:mcHardware)
可以自制/改装硬件，做一个mc游戏机，这样就能与操作系统，游戏高度贴合（借鉴各种游戏主机。最后把硬件构造设计开源）：
定制cpu/gpu架构（gpu可增加专门的chunk渲染），把它们封装在一块类似游戏主机的soc上；统一高速内存，内存布局优化（chunk，纹理，顶点按gpu缓存优化布局。预先分配对象池避免碎片化）；
存储用定制NVMe SSD；自定义i/o控制器（使ssd与cpu/gpu直接通信）；接口外设也优化；声卡优化（支持3d音效和硬件解码）；网卡正常就行；高度适配手柄

## (branch:mcweb)
个人介绍+该游戏玩法+游戏的各种衍生项目的+游戏版本控制+包管理器 可视化网站：
如果我的github仓库全都没了，那至少我的网站还在。网站不在了，那该网站的前后端代码还在，数据库还在
这个网站可以管理我各种项目的源代码，是我版本控制工具默认连接的远程仓库。也可以用做私人仓库（但是不如github上能得到更多关注，并且还要自己维护服务器）
